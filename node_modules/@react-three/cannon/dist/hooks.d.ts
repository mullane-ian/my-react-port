import type { MaterialOptions, RayOptions } from 'cannon-es';
import type { CollideBeginEvent, CollideEndEvent, CollideEvent, Event } from './setup';
import type { Euler } from 'three';
import { Object3D, Vector3 } from 'three';
import type React from 'react';
export interface AtomicProps {
    mass?: number;
    material?: MaterialOptions;
    linearDamping?: number;
    angularDamping?: number;
    allowSleep?: boolean;
    sleepSpeedLimit?: number;
    sleepTimeLimit?: number;
    collisionFilterGroup?: number;
    collisionFilterMask?: number;
    collisionResponse?: number;
    fixedRotation?: boolean;
    userData?: {};
    isTrigger?: boolean;
}
export declare type Triplet = [x: number, y: number, z: number];
declare type VectorTypes = Vector3 | Triplet;
export interface BodyProps<T = unknown> extends AtomicProps {
    args?: T;
    position?: Triplet;
    rotation?: Triplet;
    velocity?: Triplet;
    angularVelocity?: Triplet;
    linearFactor?: Triplet;
    angularFactor?: Triplet;
    type?: 'Dynamic' | 'Static' | 'Kinematic';
    onCollide?: (e: CollideEvent) => void;
    onCollideBegin?: (e: CollideBeginEvent) => void;
    onCollideEnd?: (e: CollideEndEvent) => void;
}
export interface BodyPropsArgsRequired<T = unknown> extends BodyProps<T> {
    args: T;
}
export declare type ShapeType = 'Plane' | 'Box' | 'Cylinder' | 'Heightfield' | 'Particle' | 'Sphere' | 'Trimesh' | 'ConvexPolyhedron';
export declare type BodyShapeType = ShapeType | 'Compound';
export declare type CylinderArgs = [radiusTop?: number, radiusBottom?: number, height?: number, numSegments?: number];
export declare type TrimeshArgs = [vertices: number[], indices: number[]];
export declare type HeightfieldArgs = [
    data: number[][],
    options: {
        elementSize?: number;
        maxValue?: number;
        minValue?: number;
    }
];
export declare type ConvexPolyhedronArgs<V extends VectorTypes = VectorTypes> = [
    vertices?: V[],
    faces?: number[][],
    normals?: V[],
    axes?: V[],
    boundingSphereRadius?: number
];
export declare type PlaneProps = BodyProps;
export declare type BoxProps = BodyProps<Triplet>;
export declare type CylinderProps = BodyProps<CylinderArgs>;
export declare type ParticleProps = BodyProps;
export declare type SphereProps = BodyProps<number>;
export declare type TrimeshProps = BodyPropsArgsRequired<TrimeshArgs>;
export declare type HeightfieldProps = BodyPropsArgsRequired<HeightfieldArgs>;
export declare type ConvexPolyhedronProps = BodyProps<ConvexPolyhedronArgs>;
export interface CompoundBodyProps extends BodyProps {
    shapes: BodyProps & {
        type: ShapeType;
    }[];
}
interface WorkerVec {
    set: (x: number, y: number, z: number) => void;
    copy: ({ x, y, z }: Vector3 | Euler) => void;
    subscribe: (callback: (value: Triplet) => void) => void;
}
export declare type WorkerProps<T> = {
    [K in keyof T]: {
        set: (value: T[K]) => void;
        subscribe: (callback: (value: T[K]) => void) => () => void;
    };
};
export interface WorkerApi extends WorkerProps<AtomicProps> {
    position: WorkerVec;
    rotation: WorkerVec;
    velocity: WorkerVec;
    angularVelocity: WorkerVec;
    linearFactor: WorkerVec;
    angularFactor: WorkerVec;
    applyForce: (force: Triplet, worldPoint: Triplet) => void;
    applyImpulse: (impulse: Triplet, worldPoint: Triplet) => void;
    applyLocalForce: (force: Triplet, localPoint: Triplet) => void;
    applyLocalImpulse: (impulse: Triplet, localPoint: Triplet) => void;
}
interface PublicApi extends WorkerApi {
    at: (index: number) => WorkerApi;
}
export declare type Api = [React.MutableRefObject<Object3D | undefined>, PublicApi];
export declare type ConstraintTypes = 'PointToPoint' | 'ConeTwist' | 'Distance' | 'Lock';
export interface ConstraintOptns {
    maxForce?: number;
    collideConnected?: boolean;
    wakeUpBodies?: boolean;
}
export interface PointToPointConstraintOpts extends ConstraintOptns {
    pivotA: Triplet;
    pivotB: Triplet;
}
export interface ConeTwistConstraintOpts extends ConstraintOptns {
    pivotA?: Triplet;
    axisA?: Triplet;
    pivotB?: Triplet;
    axisB?: Triplet;
    angle?: number;
    twistAngle?: number;
}
export interface DistanceConstraintOpts extends ConstraintOptns {
    distance?: number;
}
export interface HingeConstraintOpts extends ConstraintOptns {
    pivotA?: Triplet;
    axisA?: Triplet;
    pivotB?: Triplet;
    axisB?: Triplet;
}
export declare type LockConstraintOpts = ConstraintOptns;
export interface SpringOptns {
    restLength?: number;
    stiffness?: number;
    damping?: number;
    worldAnchorA?: Triplet;
    worldAnchorB?: Triplet;
    localAnchorA?: Triplet;
    localAnchorB?: Triplet;
}
declare type GetByIndex<T extends BodyProps> = (index: number) => T;
export declare function usePlane(fn: GetByIndex<PlaneProps>, fwdRef?: React.MutableRefObject<Object3D>, deps?: any[]): Api;
export declare function useBox(fn: GetByIndex<BoxProps>, fwdRef?: React.MutableRefObject<Object3D>, deps?: any[]): Api;
export declare function useCylinder(fn: GetByIndex<CylinderProps>, fwdRef?: React.MutableRefObject<Object3D>, deps?: any[]): Api;
export declare function useHeightfield(fn: GetByIndex<HeightfieldProps>, fwdRef?: React.MutableRefObject<Object3D>, deps?: any[]): Api;
export declare function useParticle(fn: GetByIndex<ParticleProps>, fwdRef?: React.MutableRefObject<Object3D>, deps?: any[]): Api;
export declare function useSphere(fn: GetByIndex<SphereProps>, fwdRef?: React.MutableRefObject<Object3D>, deps?: any[]): Api;
export declare function useTrimesh(fn: GetByIndex<TrimeshProps>, fwdRef?: React.MutableRefObject<Object3D>, deps?: any[]): Api;
export declare function useConvexPolyhedron(fn: GetByIndex<ConvexPolyhedronProps>, fwdRef?: React.MutableRefObject<Object3D>, deps?: any[]): Api;
export declare function useCompoundBody(fn: GetByIndex<CompoundBodyProps>, fwdRef?: React.MutableRefObject<Object3D>, deps?: any[]): Api;
declare type ConstraintApi = [
    React.MutableRefObject<Object3D | undefined>,
    React.MutableRefObject<Object3D | undefined>,
    {
        enable: () => void;
        disable: () => void;
    }
];
declare type HingeConstraintApi = [
    React.MutableRefObject<Object3D | undefined>,
    React.MutableRefObject<Object3D | undefined>,
    {
        enable: () => void;
        disable: () => void;
        enableMotor: () => void;
        disableMotor: () => void;
        setMotorSpeed: (value: number) => void;
        setMotorMaxForce: (value: number) => void;
    }
];
declare type SpringApi = [
    React.MutableRefObject<Object3D | undefined>,
    React.MutableRefObject<Object3D | undefined>,
    {
        setStiffness: (value: number) => void;
        setRestLength: (value: number) => void;
        setDamping: (value: number) => void;
    }
];
export declare function usePointToPointConstraint(bodyA: React.MutableRefObject<Object3D | undefined>, bodyB: React.MutableRefObject<Object3D | undefined>, optns: PointToPointConstraintOpts, deps?: any[]): ConstraintApi;
export declare function useConeTwistConstraint(bodyA: React.MutableRefObject<Object3D | undefined>, bodyB: React.MutableRefObject<Object3D | undefined>, optns: ConeTwistConstraintOpts, deps?: any[]): ConstraintApi;
export declare function useDistanceConstraint(bodyA: React.MutableRefObject<Object3D | undefined>, bodyB: React.MutableRefObject<Object3D | undefined>, optns: DistanceConstraintOpts, deps?: any[]): ConstraintApi;
export declare function useHingeConstraint(bodyA: React.MutableRefObject<Object3D | undefined>, bodyB: React.MutableRefObject<Object3D | undefined>, optns: HingeConstraintOpts, deps?: any[]): HingeConstraintApi;
export declare function useLockConstraint(bodyA: React.MutableRefObject<Object3D | undefined>, bodyB: React.MutableRefObject<Object3D | undefined>, optns: LockConstraintOpts, deps?: any[]): ConstraintApi;
export declare function useSpring(bodyA: React.MutableRefObject<Object3D | undefined>, bodyB: React.MutableRefObject<Object3D | undefined>, optns: SpringOptns, deps?: any[]): SpringApi;
declare type RayOptns = Omit<RayOptions, 'mode' | 'from' | 'to' | 'result' | 'callback'> & {
    from?: Triplet;
    to?: Triplet;
};
export declare function useRaycastClosest(options: RayOptns, callback: (e: Event) => void, deps?: any[]): void;
export declare function useRaycastAny(options: RayOptns, callback: (e: Event) => void, deps?: any[]): void;
export declare function useRaycastAll(options: RayOptns, callback: (e: Event) => void, deps?: any[]): void;
export interface RaycastVehiclePublicApi {
    applyEngineForce: (value: number, wheelIndex: number) => void;
    setBrake: (brake: number, wheelIndex: number) => void;
    setSteeringValue: (value: number, wheelIndex: number) => void;
    sliding: {
        subscribe: (callback: (sliding: boolean) => void) => void;
    };
}
export interface WheelInfoOptions {
    radius?: number;
    directionLocal?: Triplet;
    suspensionStiffness?: number;
    suspensionRestLength?: number;
    maxSuspensionForce?: number;
    maxSuspensionTravel?: number;
    dampingRelaxation?: number;
    dampingCompression?: number;
    sideAcceleration?: number;
    frictionSlip?: number;
    rollInfluence?: number;
    axleLocal?: Triplet;
    chassisConnectionPointLocal?: Triplet;
    isFrontWheel?: boolean;
    useCustomSlidingRotationalSpeed?: boolean;
    customSlidingRotationalSpeed?: number;
}
export interface RaycastVehicleProps {
    chassisBody: React.MutableRefObject<Object3D | undefined>;
    wheels: React.MutableRefObject<Object3D | undefined>[];
    wheelInfos: WheelInfoOptions[];
    indexForwardAxis?: number;
    indexRightAxis?: number;
    indexUpAxis?: number;
}
export declare function useRaycastVehicle(fn: () => RaycastVehicleProps, fwdRef?: React.MutableRefObject<Object3D>, deps?: any[]): [React.MutableRefObject<Object3D | undefined>, RaycastVehiclePublicApi];
export {};
